### &#x20;                                                  Dockerfile Best Practices

#### 1. Dockerfile、镜像、容器间的关系

    """
    Dockerfile 是软件的原材料，Docker 镜像是软件的交付品，而 Docker 容器则可以认为是软件的运行态。从应用软件的角度来看，Dockerfile、Docker 镜像与 Docker 容器分别代表软件的三个不同阶段，Dockerfile 面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。
    """

#### 2. Dockerfile

```
一个 Docker 镜像包含了很多只读层，每一层都由一个 Dockerfile 指令构成，这些层堆叠在一起，每一层都是前一层变化的增量。

每条指令都会创建一层(列举): 
> FROM：从 xxxx Docker镜像创建了一层，也作为基础镜像层。

> COPY：从 Docker 客户端的当前目录添加文件。

> RUN：执行 make 命令。

> CMD：指定要在容器中运行的命令。

```

#### 3. Dockerfile 的应用技巧

> ##### 3.1 尽可能使用官方镜像作为基础镜像
>
>     Docker 镜像是基于基础镜像构建而来，因此选择的基础镜像越恰当，我们要做的底层工作就越少。比如，如果构建一个 python 应用镜像，选择一个 python 镜像作为基础比选择一个 ubuntu 镜像更简单。
>     尽可能使用当前的官方镜像作为基础镜像，无论是从镜像大小，还是安全性来讲，都是比较可靠的。
>
> ##### 3.2 减少 Dockerfile 指令的行数
>
>     Dockerfile 中每一行指令都代表了一层，多一层都可能带来镜像大小变大。
>     因此，在实际编写 Dockerfile 时，可以将同类操作放在一起来避免多行指令，更有助于促进层缓存。比如将多条 RUN 操作进行合并， && 连接在一起。（减少指令行数，并不意味着越少越好，需要从改动频繁程度来决定是否合并为一条指令。）
>
> ##### 3.3 改动不频繁的内容往前放
>
>     对于 Docker 镜像而言，每一层都代表了 Dockerfile 中的一行指令，每一层都是前一层变化的增量。例如一个 Docker 镜像有ABCD 四层，B 层修改了，那么 BCD 都会变化。
>     因此，在编写 Dockerfile 时，尽量将改动不频繁的内容往前放，即：将系统依赖往前写，因为像 apt, yum 这些安装的东西，是很少修改的。然后写应用的库依赖，比如 pip install，最后 copy 应用,编译应用。
>
> ##### 3.4 编译和运行需分离
>
>     我们在编译应用时很多时候会用到很多编译工具、编译环境，但是编译后，运行时却不再需要。这样的编译环境往往占用很大，使得镜像额外变大。
>     因此，可以将应用事先在某个固定编译环境编译完成，得到编译后的二进制文件，再将其 COPY 到镜像中即可，这样镜像中只包含应用的运行二进制文件。
>
> ##### &#x20;3.5 删除不需要的依赖项
>
>     Docker 镜像应该尽可能小。在编写 Dockerfile 时仅包含基本内容，不要引入无关内容，从而使得镜像大小更小、构建速度更快，并且减少受攻击的可能面。
>     镜像更小，也更利于存放到镜像仓库，减少网络带宽开销。
>     不要安装应用程序实际不使用的任何包、库。
>
> ##### 3.6 避免凭证构建到镜像
>
>     这是最常见和最危险的 Dockerfile 问题之一。在构建镜像过程中，复制配置文件可能很诱人，但你切记可能会引入很大的安全隐患。
>
>     在 Dockerfile 中通过 COPY 指令将任何配置文件内容都复制到你的镜像，并且任何可以访问它的人都可以访问它。如果这个配置文件中，无意间包含了数据库密码配置，那么你就彻底将这些密码暴露给了所有使用该镜像的所有人。
>
>     为了避免这类问题，必须将配置密钥、敏感数据只能提供给具体的容器，而不是提供给构建它们的镜像。可使用环境变量、挂载卷等方式在容器启动时注入数据。这样就避免了意外的信息暴露，并确保你的镜像可跨环境重复使用。

